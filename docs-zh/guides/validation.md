---
id: validation
title: Validation
custom_edit_url: https://github.com/jaredpalmer/formik/edit/master/docs/guides/validation.md
---
Formik旨在轻松管理具有复杂验证的表单。Formik支持同步和异步表单级和字段级验证。此外，它还通过Yup为基于模式的表单级验证提供了支持。本指南将描述上述所有内容的来龙去脉。

\<AUTOGENERATED_TABLE_OF_CONTENTS>

## 验证的味道

### 表单级验证

表单级验证非常有用，因为您可以完全访问所有表单`values`并且只要函数运行，就可以使用props，这样您就可以同时验证依赖字段。

有两种方法可以使用Formik进行表单级验证：

-   `<Formik validate>`和`withFormik({ validate: ... })`
-   `<Formik validationSchema>`和`withFormik({ validationSchema: ... })`

#### `validate`

`<Formik>`和`withFormik()`采取道具/选项调用`validate`接受同步或异步功能。

```js
// Synchronous validation
const validate = (values, props /* only available when using withFormik */) => {
  let errors = {};

  if (!values.email) {
    errors.email = 'Required';
  } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$/i.test(values.email)) {
    errors.email = 'Invalid email address';
  }

  //...

  return errors;
};

// Async Validation
const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

const validate = (values, props /* only available when using withFormik */) => {
  return sleep(2000).then(() => {
    let errors = {};
    if (['admin', 'null', 'god'].includes(values.username)) {
      errors.username = 'Nice try';
    }
    // ...
    if (Object.keys(errors).length) {
      throw errors;
    }
  });
};
```

有关的更多信息`<Formik validate>`，请参阅API参考。

#### `validationSchema`

如您所见，验证由您决定。您可以随意编写自己的验证器或使用第三方库。在帕尔默集团，我们使用[对](https://github.com/jquense/yup)用于对象模式验证。它有一个非常类似的API[穰](https://github.com/hapijs/joi)和[反应PropTypes](https://github.com/facebook/prop-types)但是对于浏览器而言足够小，并且对于运行时使用来说足够快。因为我们：heart：Yup sooo很多，Formik有一个特殊的配置选项/ prop用于Yup对象模式调用`validationSchema`这将自动将Yup的验证错误转换为其键匹配的漂亮对象`values`和`touched`。这种对称性使得可以轻松地围绕错误消息管理业务逻辑。

要将Yup添加到项目中，请从NPM安装它。

```sh
npm install yup --save
# typescript users should add the @types/yup
```

```jsx
import React from 'react';
import { Formik, Form, Field } from 'formik';
import * as Yup from 'yup';

const SignupSchema = Yup.object().shape({
  firstName: Yup.string()
    .min(2, 'Too Short!')
    .max(50, 'Too Long!')
    .required('Required'),
  lastName: Yup.string()
    .min(2, 'Too Short!')
    .max(50, 'Too Long!')
    .required('Required'),
  email: Yup.string()
    .email('Invalid email')
    .required('Required'),
});

export const ValidationSchemaExample = () => (
  <div>
    <h1>Signup</h1>
    <Formik
      initialValues={{
        firstName: '',
        lastName: '',
        email: '',
      }}
      validationSchema={SignupSchema}
      onSubmit={values => {
        // same shape as initial values
        console.log(values);
      }}
    >
      {({ errors, touched }) => (
        <Form>
          <Field name="firstName" />
          {errors.firstName && touched.firstName ? (
            <div>{errors.firstName}</div>
          ) : null}
          <Field name="lastName" />
          {errors.lastName && touched.lastName ? (
            <div>{errors.lastName}</div>
          ) : null}
          <Field name="email" type="email" />
          {errors.email && touched.email ? <div>{errors.email}</div> : null}
          <button type="submit">Submit</button>
        </Form>
      )}
    </Formik>
  </div>
);
```

有关的更多信息`<Formik validationSchema>`，请参阅API参考。

### 现场级验证

#### `validate`

Formik通过支持字段级验证`<Field>`/`<FastField>`组件'`validate`支柱。此函数可以是同步的或异步的（返回Promise）。它将在任何之后运行`onChange`和`onBlur`默认情况下。此行为可以在顶级更改`<Formik/>`组件使用`validateOnChange`和`validateOnBlur`道具分别。除了更改/模糊之外，所有字段级验证都在提交尝试开始时运行，然后结果与任何顶级验证结果深度合并。

> 注意：`<Field>/<FastField>`组件'`validate`函数只能在已安装的字段上执行。也就是说，如果您的任何字段在表单流程中卸载（例如Material-UI）`<Tabs>`卸下前一个`<Tab>`您的用户已开启），在表单验证/提交期间不会验证这些字段。

```jsx
import React from 'react';
import { Formik, Form, Field } from 'formik';
import * as Yup from 'yup';

function validateEmail(value) {
  let error;
  if (!value) {
    error = 'Required';
  } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$/i.test(value)) {
    error = 'Invalid email address';
  }
  return error;
}

function validateUsername(value) {
  let error;
  if (value === 'admin') {
    error = 'Nice try!';
  }
  return error;
}

export const FieldLevelValidationExample = () => (
  <div>
    <h1>Signup</h1>
    <Formik
      initialValues={{
        username: '',
        email: '',
      }}
      onSubmit={values => {
        // same shape as initial values
        console.log(values);
      }}
    >
      {({ errors, touched, isValidating }) => (
        <Form>
          <Field name="email" validate={validateEmail} />
          {errors.email && touched.email && <div>{errors.email}</div>}

          <Field name="username" validate={validateUsername} />
          {errors.username && touched.username && <div>{errors.username}</div>}

          <button type="submit">Submit</button>
        </Form>
      )}
    </Formik>
  </div>
);
```

### 手动触发验证

您可以使用Form，使用Formik手动触发表单级和字段级验证`validateForm`和`validateField`方法分别。

```jsx
import React from 'react';
import { Formik, Form, Field } from 'formik';

function validateEmail(value) {
  let error;
  if (!value) {
    error = 'Required';
  } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$/i.test(value)) {
    error = 'Invalid email address';
  }
  return error;
}

function validateUsername(value) {
  let error;
  if (value === 'admin') {
    error = 'Nice try!';
  }
  return error;
}

export const FieldLevelValidationExample = () => (
  <div>
    <h1>Signup</h1>
    <Formik
      initialValues={{
        username: '',
        email: '',
      }}
      onSubmit={values => {
        // same shape as initial values
        console.log(values);
      }}
    >
      {({ errors, touched, validateField, validateForm }) => (
        <Form>
          <Field name="email" validate={validateEmail} />
          {errors.email && touched.email && <div>{errors.email}</div>}

          <Field name="username" validate={validateUsername} />
          {errors.username && touched.username && <div>{errors.username}</div>}
          {/** Trigger field-level validation
           imperatively */}
          <button type="button" onClick={() => validateField('username')}>
            Check Username
          </button>
          {/** Trigger form-level validation
           imperatively */}
          <button type="button" onClick={() => validateForm().then(() => console.log('blah')))}>
            Validate All
          </button>
          <button type="submit">Submit</button>
        </Form>
      )}
    </Formik>
  </div>
);
```

## 验证何时运行？

您可以通过更改值来控制Formik何时运行验证`<Formik validateOnChange>`和/或`<Formik validateOnBlur>`道具取决于你的需要。默认情况下，Formik将运行以下验证方法：

**“变更”事件/方法之后**（更新的内容`values`）

-   `handleChange`
-   `setFieldValue`
-   `setValues`

**在“模糊”事件/方法之后**（更新的内容`touched`）

-   `handleBlur`
-   `setTouched`
-   `setFieldTouched`

**每当试图提交时**

-   `handleSubmit`
-   `submitForm`

还通过Formik的呈现/注入props向您提供了必要的助手方法，您可以使用这些方法强制调用验证。

-   `validateForm`
-   `validateField`

## 显示错误消息

@托多

## 常见问题

<details>
<summary>How do I determine if my form is validating?</summary>

如果`isValidating`支柱是`true`

</details>

<details>
<summary>Can I return `null` as an error message?</summary>

不使用`undefined`相反。福美克用途`undefined`表示空状态。如果你使用`null`，福米克计算出的几个部分（例如`isValid`例如），将无法按预期工作。

</details>

<details>
<summary>How do I test validation?</summary>

formik有大量的单元测试用于yup验证，因此您不需要测试它。但是，如果您正在滚动自己的验证函数，那么您应该简单地对它们进行单元测试。如果您确实需要测试formik的执行情况，您应该使用命令`validateForm`和`validateField`方法。

</details>
